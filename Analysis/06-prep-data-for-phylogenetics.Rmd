---
title: "06-prep-data-for-phylogenetics"
author: "Ariel Marcy"
date: "11/19/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```

# Phylogenetic analyses
Evolutionary studies must take into account the phylogenetic tree because related species do not behave the same as independent samples. 

Many of these steps are based on Dr Meriam Zelditch et al.'s A Practical Companion (2012). 
> Zelditch ML Swiderski D Sheets HD . 2012. A practical companion to geometric morphometrics for biologists: running analyses in freely-available software . Available at: http://booksite.elsevier.com/9780123869036.

### Load packages, functions, and data
```{r message = FALSE}
library(stringr)  # standard packages from here on
library(data.table)
library(geomorph)
library(abind)  # needed to bind 2D arrays together into 3D arrays
library(ape)  # needed to work with phylogenies from here on
library(geiger)
library(nlme)
library(caper)
library(car)
source("../Functions/utilities.R")  # loads custom functions
load(file = "../Data/Processed/03-sm-PCA-with-color.rda")
load(file = "../Data/Processed/04-sm-data-with-traits.rda")
```

### Rename dimnames of shape array to match phylogeny
First, we'll rename the dimnames for the shape dataset so that it's only "Genus_Species". This is so we can re-order the shape data to match the tree later on. (We can still reference the CatNum in the metadata.)
```{r}
shape.phylo <- shape  # initiate shape optimized for phylogenetics
dimnames(shape.phylo)[[3]] <- as.list(paste(info.traits$Genus.y, info.traits$Species.y, sep = "_"))
```

## Calculate mean shape and centroid size for each species
This step has to be done before working with the tree. To calculate the mean shape for each species, we'll use a function from `geomorph` called `m.shape()`. 

To get the means, we'll subset for each unique species. The mean shape function, `mshape()` gives a 2D array as an output. Therefore, the `for` loop below stores mean shapes in a 2D array format recognized by `geomorph`: (n x [p x k]), where n is number of specimens, p is number of landmark points, and k is number of dimensions. Then we convert to a 3D array with format (p x k x n) since a 3D array is required by most `geomorph` functions. 
```{r}
info.traits$FullName <- paste(info.traits$Genus.y, info.traits$Species.y, sep = "_")  # give names to metadata in the same format as the tree "Genus_species"

# For loop to subset shape data by species and calculate mean shape
mean.shapes.2D <- NULL  # initiate blank data frame
for (i in 1:length(full.names)) {  
        is.taxa <- which(info.traits$FullName == full.names[i])
        shape.for.mean.2D <- shape.phylo[, , is.taxa]
        mean.shapes.2D <- rbind(mean.shapes.2D, mshape(shape.for.mean.2D))  # mshape() finds mean specimen; rbind() is critical, output cols must = 3 for 3D
}
mean.shapes <- arrayspecs(mean.shapes.2D, 325, 3)  # convert to 3D array

# Make names match the tree, make metadata match mean shape data (alphabetical)
dimnames(mean.shapes)[[3]] <- full.names  # shape names match tree names
info.means <- info.traits[!duplicated(info.traits$Taxa), -c(4, 5)]  # make metadata; remove columns that don't make sense: CatNum and Order
info.means <- info.means[order(info.means$FullName), ]  # order same as shape's
```

### Calculate mean centroid size
We need to update the centoid size column for info.means to contain the *mean* centroid size by taxa. Centroid size is stored in the info.traits metadata table.
```{r}
# Calculate mean centroid size and store in info.means
cs.means <- aggregate(info.traits[, 6], list(Taxa = info.traits$FullName), mean)
info.means$Csize <- cs.means[, 2]  # store in vector; aggregate alphabetized it
names(info.means)[names(info.means) == 'Csize'] <- 'MeanCsize'  # rename column
```

### Plot PCA of skull shape means by species
Before adding the tree, we can plot the PCA of mean shapes, which will contain more species than the set subsetted by species found in the tree.
```{r}
# Set colors for genera and different points for species within each genus
color.means <- PlotByGroup(info.means, "Genus", col.gen)  # standard colors
pch.means <- PointOutDiffSpp(info.means)  # points by unique species in a genus

# Plot PCA of mean shapes
pca.means <- plotTangentSpace(mean.shapes)
PlotPCA(pca.means, 1, 2, color.means, pch.means, flip.axis1 = TRUE, flip.axis2 = TRUE)
legend(0.142, 0.085, legend = info.means$Taxa, col = color.means, border = NULL, pch = pch.means, pt.bg = color.means, cex = 0.305)
```

### Correlation of PC1 and PC2 wtih Centroid size
Here we find Pearson's r for correlation with PC1 and PC2.
```{r}
cor.1 <- cor.test(info.means$MeanCsize, pca.means$pc.scores[, 1], method = "pearson")
cor.1  # PC1
cor.2 <- cor.test(info.means$MeanCsize, pca.means$pc.scores[, 2], method = "pearson")  # PC2
```

## Prepare the tree data for phylogenetic analyses
The commands in `geomorph` require the tree and datasets to have exactly the same set of species.

### Load in phylogenetic tree
The most recent tree for Australian rodents is from Smissen & Rowe 2018, Figure 2. The tree is a fossil calibrated ultrametric tree from BEAST2 for Hydromini, which includes all the Australo-Papuan old endemics in Murinae.
```{r}
Rowe.tree <- "../Data/Processed/Smissen-Rowe-2018-concat.tre"  # 
raw.tree <- read.tree(Rowe.tree)
```

### Extract only Genus and Species names from the tree
The tree file has uneven amounts of information for each entry, some entries have catalog numbers and others do not. Therefore we needed a `for` loop to grab the first two elements from a list, which always corresponded to Genus and Species.

We reassign only Genus and Species names (in form "Genus_species") to the tree so that going forward it is easier to compare to the shape data. 
```{r}
no.cat.tree <- raw.tree  # initiate new, modified tree with no CatNums
label.list <- strsplit(raw.tree$tip.label, "_")  # separate info into list

# For loop finds Genus & Species and reassigns tip name as "Genus_species"
for (i in 1:length(label.list)) {
        label <- unlist(label.list[i])
        no.cat.tree$tip.label[i] <- paste(label[1], label[2], sep = "_")
}
```

### Rename nodes ??
Since the 2018 Smissen & Rowe tree focused primarily on New Guinae species, it does not have all of the Australian species in our shape dataset. However, it does include sister species with the same relative branch length to other genera in the study. Therefore, we decided to rename some of the nodes with Australian species. 

**Renamed nodes:**
_Pogonomys macruourus_ (NG) to _Pogonomys mollipilosus_ (Aus)
_Melomys bannisteri_ (NG) to _Melomys burtoni_ (Aus)

```{r}
renamed.tree <- no.cat.tree
P.mac <- which(str_detect(no.cat.tree$tip.label, "Pogonomys_macrourus"))
renamed.tree$tip.label[P.mac] <- paste("Pogonomys_mollipilosis")

M.ban <- which(str_detect(no.cat.tree$tip.label, "Melomys_bannisteri"))
renamed.tree$tip.label[M.ban] <- paste("Melomys_burtoni")

# Optional plot
plot(renamed.tree)
tiplabels(cex = 0.1)
nodelabels(cex = 0.1)
axisPhylo()
```

### Prune the shape dataset
Now that the names in the Smissen & Rowe tree can be compared to our info.traits metadata, we can shape dataset to have all the same species.

First, Re-order the metadata and shape datasets to match the order of species found in the tree. We created a function, `MatchedTips()` to do most of the work (see utilities.R).
```{r}


# prune species not in tree


# MatchedTips()$matched is a vector of indices matching the shape data to the tree with no duplicated/replicated entries of the tree. See more in utlities.R.
MatchTips(renamed.tree, unique(info.traits$FullName))

info.tree <- info.traits[MatchTips(renamed.tree, info.traits$FullName)$matched, ]
shape.tree <- shape[ , , MatchTips(renamed.tree, dimnames(shape)[[3]])$matched]
```


```{r}
# Prune tree
concord <- name.check(renamed.tree, info.traits$FullName)  # check concordance
aus.tree <- drop.tip(renamed.tree, concord$tree_not_data)  # prune tree to Aus
name.check(aus.tree, info.traits$FullName)  # double check

```


### Prune the tree to match the shape dataset

```{r}
drop.tree

```







# Basement


## Calculate mean shape for each species with `select.procrustes()`
This step has to be done before working with the tree. To calculate the mean shape for each species, we'll use a function from the new package, `landvR`. The results are the same as `geomorph`'s `m.shape()` applied to the shape data, subsetted for each genera (evaluated as the same using all.equal() -Dr Thomas Guillerme, `landvR` author).
```{r}
# Define genera in data frame with for loop using which
genus.names <- sort(unique(info.traits$Genus))
genus <- NULL  # initiate blank data frame
for (i in 1:length(genus.names)) {
        is.genus <- which(info.traits$Genus == genus.names[i])
        genus.col <- c(is.genus, rep(NA, (78 - length(is.genus))))
        genus <- cbind(genus, genus.col)
}
colnames(genus) <- genus.names
genus2 <- as.data.frame(genus)  # required for subsetting with $ in next step

# Calculate mean shape
genus.groups = list("Hyd" = na.omit(genus$Hyd), "Leg" = na.omit(genus$Leg),                          "Lep" = na.omit(genus$Lep), "Mas" = na.omit(genus$Mas),                          "Mel" = na.omit(genus$Mel), "Mes" = na.omit(genus$Mes),                          "Mus" = na.omit(genus$Mus), "Not" = na.omit(genus$Not),                          "Pog" = na.omit(genus$Pog), "Pse" = na.omit(genus$Pse),                          "Rat" = na.omit(genus$Rat), "Uro" = na.omit(genus$Uro),                          "Xer" = na.omit(genus$Xer), "Zyz" = na.omit(genus$Zyz))

mean.shapes <- select.procrustes(shape, selector = mean, factors = genus.groups)
mean.shapes.arr <- arrayspecs(as.data.frame(mshapes.df.t), 279, 3)

genus.key <- cbind(1:14, as.vector(genus.names))
mean.genus.color <- PlotByGroup(genus.key, 2, col.gen)
PlotPCA(mean.shapes, 1, 2, mean.genus.color, flip.axis1 = TRUE)  # NOT WORKING
```




Testing trees
```{r}
test.tree <- rtree(6, tip.label = letters[1:6])
test.shape <- c(letters[1:6])

MatchTips(test.tree, test.shape)
```


2) Put the list of shape specimens in the same order as the tree.
```{r}
# Make a list of shape specimens in the same order as the tree
is.in.tree <- !is.na(tree.index)
spp.in.tree <- spp.in.shape[is.in.tree]  # remove species not in tree
in.tree.index <- tree.index[is.in.tree]  # remove 0's of species not in tree
spp.in.tree.order <- spp.in.tree[order(in.tree.index)]  # spp ordered like tree
```

3) Subset the metadata and shape datasets by the specimens in the tree.
```{r}
# Find index numbers of species in tree, return NA if not present
tree.index.meta <- vector()
for (i in 1:dim(info.traits)[1]) {
       tree.index.meta <- c(tree.index.meta, (match(info.traits$FullName[i], spp.in.tree)))
}
is.in.tree.meta <- !is.na(tree.index.meta)  # converts index numbers to logical

# Subset the datasets
info.tree <- info.traits[is.in.tree.meta, ]  # metadata
shape.tree <- shape[, , is.in.tree.meta]  # shape data

### 4) 
# Match the index numbers to species name with a new column
tree.key <- as.data.frame(cbind(in.tree.index, spp.in.tree))
colnames(tree.key) <- c("Index", "FullName")

# Merge new key with metadata and sort the way the dimnames of shape will order the specimens: FullName (which Index covers) and then CatNum
info.tree <- merge(info.tree, tree.key, by = "FullName")
info.tree <- info.tree[order(info.tree$Index, info.tree$CatNum), ]  # re-ordered
```

### Prob trash
```{r}
# Make FullName column for shape data
spp.in.shape <- unique(info.traits$FullName)

# Test which are present in the tree, and if present return index of spp in tree
tree.index <- vector()
for (spp in spp.in.shape) {
       tree.index <- c(tree.index, (match(spp, spp.in.tree$FullName)))
}
```