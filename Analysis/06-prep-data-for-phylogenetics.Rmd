---
title: "06-prep-data-for-phylogenetics"
author: "Ariel Marcy"
date: "11/19/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```

# Phylogenetic analyses
Evolutionary studies must take into account the phylogenetic tree because related species do not behave the same as independent samples. 

Many of these steps are based on Dr Meriam Zelditch et al.'s A Practical Companion (2012). 
> Zelditch ML Swiderski D Sheets HD . 2012. A practical companion to geometric morphometrics for biologists: running analyses in freely-available software . Available at: http://booksite.elsevier.com/9780123869036.

### Load packages, functions, and data
```{r message = FALSE}
install_github("TGuillerme/landvR", ref = "release") 

library(ape)  # needed to work with phylogenies
library(geiger)
library(nlme)
library(caper)
library(car)
library(stringr)  # standard packages from here on
library(data.table)
library(geomorph)
library(devtools) 
library(landvR)  # has select.procrustes() function
source("../Functions/utilities.R")  # loads custom functions
load(file = "../Data/Processed/03-sm-data-for-analyses.rda")
load(file = "../Data/Processed/04-sm-data-w-traits.rda")
```

### Rename dimnames of shape array to match phylogeny
First, we'll rename the dimnames for the shape dataset so that it's only "Genus_Species". We can still reference the CatNum in the metadata.
```{r}
shape.phylo <- shape  # initiate shape optimized for phylogenetics
dimnames(shape.phylo)[[3]] <- as.list(paste(info.traits$Genus.y, info.traits$Species.y, sep = "_"))
```

## Calculate mean shape for each species
This step has to be done before working with the tree. To calculate the mean shape for each species, we'll use a function from the new package, `landvR`. The results are the same as `geomorph`'s `m.shape()` applied to the shape data, subsetted for each genera (evaluated as the same using all.equal() - Dr Thomas Guillerme, `landvR` author).
```{r}
# Define genera with for loop using which
genus.names <- sort(unique(info.traits$Genus))
genus <- NULL
for (i in 1:length(genus.names)) {
        is.genus <- which(info.traits$Genus == genus.names[i])
        genus.col <- c(is.genus, rep(NA, (10 - length(is.genus))))
        genus <- cbind(genus, genus.col)
}
colnames(genus) <- genus.names

Hyd <- which(info.traits$Genus == "Hyd")
Leg <- which(info.traits$Genus == "Leg")

mean.gen.shape <- select.procrustes(shape, selector = mean, factors = genera)
```


## Prepare the tree data for phylogenetic analyses
The commands in `geomorph` require the tree and datasets to have exactly the same set of species.

### Load in phylogenetic tree
The most recent tree for Australian rodents is from Smissen & Rowe 2018, Figure 2. The tree is a fossil calibrated ultrametric tree from BEAST2 for Hydromini, which includes all the Australo-Papuan old endemics in Murinae.
```{r}
Rowe.tree <- "../Data/Processed/Smissen-Rowe-2018-concat.tre"  # 
raw.tree <- read.tree(Rowe.tree)
```

### Extract only Genus and Species names from the tree
The tree file has uneven amounts of information for each entry, some entries have catalog numbers and others do not. Therefore we needed a `for` loop to grab the first two elements from a list, which always corresponded to Genus and Species.

We reassign only Genus and Species names (in form "Genus_species") to the tree so that going forward it is easier to compare to the shape data. 
```{r}
no.cat.tree <- raw.tree  # initiate new, modified tree with no CatNums
label.list <- strsplit(raw.tree$tip.label, "_")  # separate info into list

# For loop finds Genus & Species and reassigns tip name as "Genus_species"
for (i in 1:length(label.list)) {
        label <- unlist(label.list[i])
        no.cat.tree$tip.label[i] <- paste(label[1], label[2], sep = "_")
}
```

### Rename nodes ??
Since the 2018 Smissen & Rowe tree focused primarily on New Guinae species, it does not have all of the Australian species in our shape dataset. However, it does include sister species with the same relative branch length to other genera in the study. Therefore, we decided to rename some of the nodes with Australian species. 

**Renamed nodes:**
_Pogonomys macruourus_ (NG) to _Pogonomys mollipilosus_ (Aus)
_Melomys bannisteri_ (NG) to _Melomys burtoni_ (Aus)

```{r}
renamed.tree <- no.cat.tree
P.mac <- which(str_detect(no.cat.tree$tip.label, "Pogonomys_macrourus"))
renamed.tree$tip.label[P.mac] <- paste("Pogonomys_mollipilosis")

M.ban <- which(str_detect(no.cat.tree$tip.label, "Melomys_bannisteri"))
renamed.tree$tip.label[M.ban] <- paste("Melomys_burtoni")

# Optional plot
plot(renamed.tree)
tiplabels(cex = 0.1)
nodelabels(cex = 0.1)
axisPhylo()
```

### Prune the tree and shape dataset
Now that the names in our info.traits metadata can be compared to the Smissen & Rowe tree, we can prune the tree and shape datasets to have all the same species.

First, Re-order the metadata and shape datasets to match the order of species found in the tree. We created a function to do most of the work (see utilities.R).
```{r}
info.traits$FullName <- paste(info.traits$Genus.y, info.traits$Species.y, sep = "_")  # give names to metadata in the same format as the tree "Genus_species"



# MatchedTips()$matched is a vector of indices matching the shape data to the tree with no duplicated/replicated entries of the tree. See more in utlities.R.
MatchTips(renamed.tree, unique(info.traits$FullName))

info.tree <- info.traits[MatchTips(renamed.tree, info.traits$FullName)$matched, ]
shape.tree <- shape[ , , MatchTips(renamed.tree, dimnames(shape)[[3]])$matched]

```


```{r}
# Prune tree
concord <- name.check(renamed.tree, info.traits$FullName)  # check concordance
aus.tree <- drop.tip(renamed.tree, concord$tree_not_data)  # prune tree to Aus
name.check(aus.tree, info.traits$FullName)  # double check

```


### Prune the tree to match the shape dataset

```{r}
drop.tree

```







### Basement
Testing trees
```{r}
test.tree <- rtree(6, tip.label = letters[1:6])
test.shape <- c(letters[1:6])

MatchTips(test.tree, test.shape)
```


2) Put the list of shape specimens in the same order as the tree.
```{r}
# Make a list of shape specimens in the same order as the tree
is.in.tree <- !is.na(tree.index)
spp.in.tree <- spp.in.shape[is.in.tree]  # remove species not in tree
in.tree.index <- tree.index[is.in.tree]  # remove 0's of species not in tree
spp.in.tree.order <- spp.in.tree[order(in.tree.index)]  # spp ordered like tree
```

3) Subset the metadata and shape datasets by the specimens in the tree.
```{r}
# Find index numbers of species in tree, return NA if not present
tree.index.meta <- vector()
for (i in 1:dim(info.traits)[1]) {
       tree.index.meta <- c(tree.index.meta, (match(info.traits$FullName[i], spp.in.tree)))
}
is.in.tree.meta <- !is.na(tree.index.meta)  # converts index numbers to logical

# Subset the datasets
info.tree <- info.traits[is.in.tree.meta, ]  # metadata
shape.tree <- shape[, , is.in.tree.meta]  # shape data

### 4) 
# Match the index numbers to species name with a new column
tree.key <- as.data.frame(cbind(in.tree.index, spp.in.tree))
colnames(tree.key) <- c("Index", "FullName")

# Merge new key with metadata and sort the way the dimnames of shape will order the specimens: FullName (which Index covers) and then CatNum
info.tree <- merge(info.tree, tree.key, by = "FullName")
info.tree <- info.tree[order(info.tree$Index, info.tree$CatNum), ]  # re-ordered
```

### Prob trash
```{r}
# Make FullName column for shape data
spp.in.shape <- unique(info.traits$FullName)

# Test which are present in the tree, and if present return index of spp in tree
tree.index <- vector()
for (spp in spp.in.shape) {
       tree.index <- c(tree.index, (match(spp, spp.in.tree$FullName)))
}
```